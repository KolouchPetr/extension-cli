{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Extension CLI Extension CLI provides command-line build tools that facilitate rapid chrome extension development by providing systematic way to build, test and document extension projects. Getting Started & Docs Basic install: npm install extension-cli Quick Command Reference Command Description xt-build Run builds; env flags: -e prod and -e dev xt-test Run unit tests xt-docs Generate docs xt-sync Update project config files to match the latest defaults supplied by this CLI xt-clean Remove automatically generated files Note that for each command --help and --version flags are also valid Read these docs for more detailed guides! Extension CLI is made by Mobile First in Augusta, GA! Star Fork Issue Watch","title":"About"},{"location":"#extension-cli","text":"Extension CLI provides command-line build tools that facilitate rapid chrome extension development by providing systematic way to build, test and document extension projects.","title":"Extension CLI"},{"location":"#getting-started-docs","text":"Basic install: npm install extension-cli","title":"Getting Started &amp; Docs"},{"location":"#quick-command-reference","text":"Command Description xt-build Run builds; env flags: -e prod and -e dev xt-test Run unit tests xt-docs Generate docs xt-sync Update project config files to match the latest defaults supplied by this CLI xt-clean Remove automatically generated files Note that for each command --help and --version flags are also valid Read these docs for more detailed guides! Extension CLI is made by Mobile First in Augusta, GA! Star Fork Issue Watch","title":"Quick Command Reference"},{"location":"helpful/","text":"Helpful Links Some generally helpful links that may be of assistance when working with extension projects Chrome Extension Development Resources manifest.json reference Webstore Image Guide","title":"Helpful References"},{"location":"helpful/#helpful-links","text":"Some generally helpful links that may be of assistance when working with extension projects","title":"Helpful Links"},{"location":"helpful/#chrome-extension-development-resources","text":"manifest.json reference Webstore Image Guide","title":"Chrome Extension Development Resources"},{"location":"release-notes/","text":"Release Notes 0.8.8 (2020-04-08) Upgraded project dependencies 0.8.7 (2020-01-17) Upgraded project dependencies Fixed scripts build step (changed webpack options) 0.8.6 (2019-12-21) Initial release for this publisher Migrated project from older source code Upgraded all packages Migrated build to use Gulp v4","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#088-2020-04-08","text":"Upgraded project dependencies","title":"0.8.8 (2020-04-08)"},{"location":"release-notes/#087-2020-01-17","text":"Upgraded project dependencies Fixed scripts build step (changed webpack options)","title":"0.8.7 (2020-01-17)"},{"location":"release-notes/#086-2019-12-21","text":"Initial release for this publisher Migrated project from older source code Upgraded all packages Migrated build to use Gulp v4","title":"0.8.6 (2019-12-21)"},{"location":"showcase/","text":"List of Projects Alphabetical list by app name Name Maker Badge Download All Images Mobile First Sitemap Generator nkrusch Open Source Projects on Github See Dependency Graph Add your own project! Edit this file on Github to add your project, then submit a PR","title":"Showcase"},{"location":"showcase/#list-of-projects","text":"Alphabetical list by app name Name Maker Badge Download All Images Mobile First Sitemap Generator nkrusch","title":"List of Projects"},{"location":"showcase/#open-source-projects-on-github","text":"See Dependency Graph","title":"Open Source Projects on Github"},{"location":"showcase/#add-your-own-project","text":"Edit this file on Github to add your project, then submit a PR","title":"Add your own project!"},{"location":"guide/configuration/","text":"Configuration Before you start using Extension CLI, you have to add some configuration options to your package.json . If your project does not contain package.json , first run npm init And follow the on-screen setup. Then, update extension project package.json with following options: Babel Presets Needed to compile projects written in ES6. \"babel\": { \"presets\": [ \"@babel/preset-env\" ] } ESLint Ignore Exclude test files from being linted. If your project includes compiled 3rd party libraries, you should exclude them also. \"eslintIgnore\": [ \"test/**/*\" ] Add Scripts Add these scripts to package.json then you can run, for example, npm run start . \"scripts\": { \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", \"clean\": \"xt-clean\", \"docs\": \"xt-docs\", \"test\": \"xt-test\" }","title":"Configuration"},{"location":"guide/configuration/#configuration","text":"Before you start using Extension CLI, you have to add some configuration options to your package.json . If your project does not contain package.json , first run npm init And follow the on-screen setup. Then, update extension project package.json with following options:","title":"Configuration"},{"location":"guide/configuration/#babel-presets","text":"Needed to compile projects written in ES6. \"babel\": { \"presets\": [ \"@babel/preset-env\" ] }","title":"Babel Presets"},{"location":"guide/configuration/#eslint-ignore","text":"Exclude test files from being linted. If your project includes compiled 3rd party libraries, you should exclude them also. \"eslintIgnore\": [ \"test/**/*\" ]","title":"ESLint Ignore"},{"location":"guide/configuration/#add-scripts","text":"Add these scripts to package.json then you can run, for example, npm run start . \"scripts\": { \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", \"clean\": \"xt-clean\", \"docs\": \"xt-docs\", \"test\": \"xt-test\" }","title":"Add Scripts"},{"location":"guide/getting-started/","text":"Getting Started Prerequisites Before using extension CLI, you should have all of the following: Node.js Any web-friendly IDE Terminal/cmd access Chrome browser for debugging extensions Installation Install latest CLI version from NPM npm install extension-cli Default Project Organization Before you start using the CLI, inspect your project file structure. You can override most of these paths when specifying build and documentation settings, but if you are starting a new project, this organization will matches the CLI defaults. Path Description \u2514 assets static assets \u2514\u2500 img Extension icons \u2514\u2500 locales Localized string resources \u2514\u2500 en/messages.json English dictionary \u2514 src Source code: put js, scss, html, json files here \u2514\u2500 manifest.json Extension manifest \u2514 test Unit tests \u2514 package.json Application root","title":"\u2605 Getting Started"},{"location":"guide/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"guide/getting-started/#prerequisites","text":"Before using extension CLI, you should have all of the following: Node.js Any web-friendly IDE Terminal/cmd access Chrome browser for debugging extensions","title":"Prerequisites"},{"location":"guide/getting-started/#installation","text":"Install latest CLI version from NPM npm install extension-cli","title":"Installation"},{"location":"guide/getting-started/#default-project-organization","text":"Before you start using the CLI, inspect your project file structure. You can override most of these paths when specifying build and documentation settings, but if you are starting a new project, this organization will matches the CLI defaults. Path Description \u2514 assets static assets \u2514\u2500 img Extension icons \u2514\u2500 locales Localized string resources \u2514\u2500 en/messages.json English dictionary \u2514 src Source code: put js, scss, html, json files here \u2514\u2500 manifest.json Extension manifest \u2514 test Unit tests \u2514 package.json Application root","title":"Default Project Organization"},{"location":"guide/xt-build/","text":"xt-build xt-build command is used for generating a debuggable dev version of an extension project. It is also used to create a production ready, minified .zip file that can be uploaded to the chrome web store. Successful build command always generates an extension dist/ directory that can be debugged in the browser. The underlying build system uses gulp , babel and webpack to compile scripts (among other plugins). Dev Build Artifacts When specifying dev build flag, the build will complete using development settings. The output of a successful dev build is a dist/ directory which can be debugged using the chrome browser. The build command will always compile scripts using production settings, because extension scripts must be compiled prior to debugging ( eval is not allowed). Prod Build Artifacts When specifying prod build flag, the build will run a production build. Successful production build will generate a dist/ directory of extension files which can be debugged in the browser. It will also generate a release.zip file in the project root strictly based on the files in the dist directory. This zip file can be uploaded directly to the Chrome Web Store. When running a production build, all code files (js, sass, html, json) will be minified. Commands Run production build (default) xt-build Run production build using explicit flag xt-build -e prod Run development build xt-build -e dev Command using custom configuration file path xt-build --config \"/path/to/config.json\" Run development build and keep watching changes xt-build -e dev --watch Get help using this command xt-build --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-build . Or you can add an option to packages.json scripts section (see example below) and then execute the command as npm run build or npm run start . \"scripts\":{ \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", } Build Configuration By default the CLI will look for build configuration in two different places: - in package.json using key xtbuild - in a file named .xtbuild.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with --config ( -c ) flag, followed by path to file. See commands for an example . The CLI uses a default build configuration file shown below. This tells the extension CLI where to look for files and where to output files. You can override any of these key-value pairs at project level. You can find more detailed explanations of usage of some of these keys below . { \"projectRootDir\": \"../../../\", \"dist\": \"./dist\", \"source\": \"./src\", \"releases\": \"./\", \"manifest\": \"./src/manifest.json\", \"js\": \"./src/**/*.js\", \"js_bundles\": null, \"html\": \"./src/**/*.html\", \"scss\": \"./src/**/*.scss\", \"scss_bundles\": null, \"icons\":[ images, images, images, images ], \"copyAsIs\": [], \"locales_dir\": \"./assets/locales/\", \"locales_list\": [\"en\"] } Custom Configurations Script Bundles js_bundles key used to configure build settings for javascript bundles. You will need to configure bundles when your compiled extension contains more than 1 javascript file. The expected value for js_bundles is an array with one or more items as shown in the example below. name is the output bundle filename without file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). Example Sample project-level configuration with multiple javascript bundles \"xtbuild\": { \"js_bundles\": [ { \"name\": \"background\", \"src\": \"./src/background.js\" }, { \"name\": \"app\", \"src\": [ \"./src/app/inbox/**/*.js\", \"./src/app/message/**/*.js\" ] } ] } Skip Javascript Compilation and Linting Use copyAsIs key to specify an array of files which should not be compiled. These files can be located anywhere in your project. The build command will copy specified files exactly without any modification to the root of the output directory. Any path will be flattened. Example Sample configuration for skipping compilation of pre-compiled files \"xtbuild\": { \"copyAsIs\": [ \"./node_modules/material-design-lite/material.min.js\", \"./assets/ga.js\" ] } In the project-level package.json , add the file paths to the list of ignored files to prevent them from being linted. { \"eslintIgnore\": [ \"test/**/*\", \"./assets/ga.js\" ] } Style bundles scss_bundles are used to configure build settings for css-style files. The expected value is an array with one or more items as shown in the example below. The property value name is the output bundle filename with file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). When using production build the style files will be minified. Dev build does not minify style files. By default, the stylesheets are assumed to be written using Sass . If you are not a friend of Sass language stylesheets, you can write your style sheets using regular CSS. However name your files using .scss file extension, or override the default configuration: \"scss\": \"./src/**/*.scss\", because this means the CLI will by default only look for .scss style files. Example Sample project-level configuration with multiple style bundles \"xtbuild\": { \"scss_bundles\": [ { \"src\": [ \"./src/**/*.scss\", \"!./src/app/styles/message.scss\" ], \"name\": \"styles.css\" }, { \"src\": [ \"./src/app/styles/message.scss\" ], \"name\": \"display.css\" } ] } Localization If the extension supports multiple languages, specify all supported languages using key locales_list . The default language value is [\"en\"] . This locales_list should be an array that corresponds to a list of subdirectories under locales_dir in the extension project. The default locales_dir is ./assets/locales/ , which you may change if you want. Refer to this list of language codes when naming individual language directories. Example Multiple locales example with custom path to locales files \"xtbuild\": { \"locales_dir\": \"./my/custom/locales/path/\", \"locales_list\": [\"en\",\"en-GB\",\"pl\"] } Given the configuration above, the following project-level directories are expected. File Path Description \u2514 /my/custom/locales/path/ path to locales \u2514\u2500 en /messages.json Default English dictionary \u2514\u2500 en-GB /messages.json British dictionary \u2514\u2500 pl/ Polish language dictionaries \u2514\u2500 app.json Polish language dictionaries \u2514\u2500 options.json Polish language dictionaries You can break down your locales files into multiple .json files within the language-specific directory as shown in the example above for pl/ . This may make the maintenance locales files easier if the files contain multiple entries. The build step will automatically combine all files within a language directory into a single messages.json which is expected from browser extensions. Image Assets By default extension CLI will look for image assets from the following paths: \"icons\": [ \"./assets/img/**/*.png\", \"./assets/img/**/*.gif\", \"./assets/img/**/*.jpg\", \"./assets/img/**/*.svg\" ], You may change this configuration if the project image assets are located elsewhere or if you want to support additional image file extensions. After the build step, all image assets will be located in the /dist/icons directory. Therefore, in your extension project manifest.json you would refer to them as follows: \"browser_action\": { \"default_icon\": { \"16\": \"icons/16x16.png\", \"24\": \"icons/24x24.png\", \"32\": \"icons/32x32.png\" } }","title":"xt-build"},{"location":"guide/xt-build/#xt-build","text":"xt-build command is used for generating a debuggable dev version of an extension project. It is also used to create a production ready, minified .zip file that can be uploaded to the chrome web store. Successful build command always generates an extension dist/ directory that can be debugged in the browser. The underlying build system uses gulp , babel and webpack to compile scripts (among other plugins).","title":"xt-build"},{"location":"guide/xt-build/#dev-build-artifacts","text":"When specifying dev build flag, the build will complete using development settings. The output of a successful dev build is a dist/ directory which can be debugged using the chrome browser. The build command will always compile scripts using production settings, because extension scripts must be compiled prior to debugging ( eval is not allowed).","title":"Dev Build Artifacts"},{"location":"guide/xt-build/#prod-build-artifacts","text":"When specifying prod build flag, the build will run a production build. Successful production build will generate a dist/ directory of extension files which can be debugged in the browser. It will also generate a release.zip file in the project root strictly based on the files in the dist directory. This zip file can be uploaded directly to the Chrome Web Store. When running a production build, all code files (js, sass, html, json) will be minified.","title":"Prod Build Artifacts"},{"location":"guide/xt-build/#commands","text":"Run production build (default) xt-build Run production build using explicit flag xt-build -e prod Run development build xt-build -e dev Command using custom configuration file path xt-build --config \"/path/to/config.json\" Run development build and keep watching changes xt-build -e dev --watch Get help using this command xt-build --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-build . Or you can add an option to packages.json scripts section (see example below) and then execute the command as npm run build or npm run start . \"scripts\":{ \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", }","title":"Commands"},{"location":"guide/xt-build/#build-configuration","text":"By default the CLI will look for build configuration in two different places: - in package.json using key xtbuild - in a file named .xtbuild.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with --config ( -c ) flag, followed by path to file. See commands for an example . The CLI uses a default build configuration file shown below. This tells the extension CLI where to look for files and where to output files. You can override any of these key-value pairs at project level. You can find more detailed explanations of usage of some of these keys below . { \"projectRootDir\": \"../../../\", \"dist\": \"./dist\", \"source\": \"./src\", \"releases\": \"./\", \"manifest\": \"./src/manifest.json\", \"js\": \"./src/**/*.js\", \"js_bundles\": null, \"html\": \"./src/**/*.html\", \"scss\": \"./src/**/*.scss\", \"scss_bundles\": null, \"icons\":[ images, images, images, images ], \"copyAsIs\": [], \"locales_dir\": \"./assets/locales/\", \"locales_list\": [\"en\"] }","title":"Build Configuration"},{"location":"guide/xt-build/#custom-configurations","text":"","title":"Custom Configurations"},{"location":"guide/xt-build/#script-bundles","text":"js_bundles key used to configure build settings for javascript bundles. You will need to configure bundles when your compiled extension contains more than 1 javascript file. The expected value for js_bundles is an array with one or more items as shown in the example below. name is the output bundle filename without file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options).","title":"Script Bundles"},{"location":"guide/xt-build/#example","text":"Sample project-level configuration with multiple javascript bundles \"xtbuild\": { \"js_bundles\": [ { \"name\": \"background\", \"src\": \"./src/background.js\" }, { \"name\": \"app\", \"src\": [ \"./src/app/inbox/**/*.js\", \"./src/app/message/**/*.js\" ] } ] }","title":"Example"},{"location":"guide/xt-build/#skip-javascript-compilation-and-linting","text":"Use copyAsIs key to specify an array of files which should not be compiled. These files can be located anywhere in your project. The build command will copy specified files exactly without any modification to the root of the output directory. Any path will be flattened.","title":"Skip Javascript Compilation and Linting"},{"location":"guide/xt-build/#example_1","text":"Sample configuration for skipping compilation of pre-compiled files \"xtbuild\": { \"copyAsIs\": [ \"./node_modules/material-design-lite/material.min.js\", \"./assets/ga.js\" ] } In the project-level package.json , add the file paths to the list of ignored files to prevent them from being linted. { \"eslintIgnore\": [ \"test/**/*\", \"./assets/ga.js\" ] }","title":"Example"},{"location":"guide/xt-build/#style-bundles","text":"scss_bundles are used to configure build settings for css-style files. The expected value is an array with one or more items as shown in the example below. The property value name is the output bundle filename with file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). When using production build the style files will be minified. Dev build does not minify style files. By default, the stylesheets are assumed to be written using Sass . If you are not a friend of Sass language stylesheets, you can write your style sheets using regular CSS. However name your files using .scss file extension, or override the default configuration: \"scss\": \"./src/**/*.scss\", because this means the CLI will by default only look for .scss style files.","title":"Style bundles"},{"location":"guide/xt-build/#example_2","text":"Sample project-level configuration with multiple style bundles \"xtbuild\": { \"scss_bundles\": [ { \"src\": [ \"./src/**/*.scss\", \"!./src/app/styles/message.scss\" ], \"name\": \"styles.css\" }, { \"src\": [ \"./src/app/styles/message.scss\" ], \"name\": \"display.css\" } ] }","title":"Example"},{"location":"guide/xt-build/#localization","text":"If the extension supports multiple languages, specify all supported languages using key locales_list . The default language value is [\"en\"] . This locales_list should be an array that corresponds to a list of subdirectories under locales_dir in the extension project. The default locales_dir is ./assets/locales/ , which you may change if you want. Refer to this list of language codes when naming individual language directories.","title":"Localization"},{"location":"guide/xt-build/#example_3","text":"Multiple locales example with custom path to locales files \"xtbuild\": { \"locales_dir\": \"./my/custom/locales/path/\", \"locales_list\": [\"en\",\"en-GB\",\"pl\"] } Given the configuration above, the following project-level directories are expected. File Path Description \u2514 /my/custom/locales/path/ path to locales \u2514\u2500 en /messages.json Default English dictionary \u2514\u2500 en-GB /messages.json British dictionary \u2514\u2500 pl/ Polish language dictionaries \u2514\u2500 app.json Polish language dictionaries \u2514\u2500 options.json Polish language dictionaries You can break down your locales files into multiple .json files within the language-specific directory as shown in the example above for pl/ . This may make the maintenance locales files easier if the files contain multiple entries. The build step will automatically combine all files within a language directory into a single messages.json which is expected from browser extensions.","title":"Example"},{"location":"guide/xt-build/#image-assets","text":"By default extension CLI will look for image assets from the following paths: \"icons\": [ \"./assets/img/**/*.png\", \"./assets/img/**/*.gif\", \"./assets/img/**/*.jpg\", \"./assets/img/**/*.svg\" ], You may change this configuration if the project image assets are located elsewhere or if you want to support additional image file extensions. After the build step, all image assets will be located in the /dist/icons directory. Therefore, in your extension project manifest.json you would refer to them as follows: \"browser_action\": { \"default_icon\": { \"16\": \"icons/16x16.png\", \"24\": \"icons/24x24.png\", \"32\": \"icons/32x32.png\" } }","title":"Image Assets"},{"location":"guide/xt-clean/","text":"xt-clean xt-clean command removes all automatically generated files from the project directories. Clean operation iterates over files and directories listed in the project .gitignore file, and removes all ignored files and directories, except node_modules/ , .idea/ , and .vscode/ . .idea is a collection of configuration files used by WebStorm IDE, and .vscode is the same for Visual Studio Code. The IDE will generate them automatically if they are absent. To remove these three directories, you must explicitly pass a flag to delete each directory respectively. Commands Remove ignored files (default) xt-clean Clear ignored files, including node_modules xt-clean -m Clear ignored files, including .idea/ directory xt-clean -i Clear ignored files, including .vscode/ directory xt-clean -v Clear absolutely all ignored files xt-clean -v -i -m Get help using this command xt-clean --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-clean . Or you can add an option to packages.json scripts section and then execute the command as npm run clean See example below. \"scripts\":{ \"clean\": \"xt-clean\" }","title":"xt-clean"},{"location":"guide/xt-clean/#xt-clean","text":"xt-clean command removes all automatically generated files from the project directories. Clean operation iterates over files and directories listed in the project .gitignore file, and removes all ignored files and directories, except node_modules/ , .idea/ , and .vscode/ . .idea is a collection of configuration files used by WebStorm IDE, and .vscode is the same for Visual Studio Code. The IDE will generate them automatically if they are absent. To remove these three directories, you must explicitly pass a flag to delete each directory respectively.","title":"xt-clean"},{"location":"guide/xt-clean/#commands","text":"Remove ignored files (default) xt-clean Clear ignored files, including node_modules xt-clean -m Clear ignored files, including .idea/ directory xt-clean -i Clear ignored files, including .vscode/ directory xt-clean -v Clear absolutely all ignored files xt-clean -v -i -m Get help using this command xt-clean --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-clean . Or you can add an option to packages.json scripts section and then execute the command as npm run clean See example below. \"scripts\":{ \"clean\": \"xt-clean\" }","title":"Commands"},{"location":"guide/xt-create/","text":"xt-create (planned) xt-create command is used to create a new extension project. Commands Default command xt-create Get help using this command xt-create --help This command should be run from outside existing project. May require global installation of the CLI (?).","title":"xt-create"},{"location":"guide/xt-create/#xt-create-planned","text":"xt-create command is used to create a new extension project.","title":"xt-create (planned)"},{"location":"guide/xt-create/#commands","text":"Default command xt-create Get help using this command xt-create --help This command should be run from outside existing project. May require global installation of the CLI (?).","title":"Commands"},{"location":"guide/xt-docs/","text":"xt-docs xt-docs command is used for generating source code documentation for an extension project. Extension CLI uses JSDoc 3 specification to generate documentation for javascript files in an extension project. JSDoc is a flexible documentation generator that converts javascript code comments to readable HTML/CSS files which you can be hosted for example with github pages. You can use any compatible template of choice to skin your docs. Learn more about templating here . Commands Default command xt-docs Command using custom configuration file path xt-docs --config \"/path/to/config.json\" Get help using this command xt-docs --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-docs . Or you can add an option to packages.json scripts section and then execute the command as npm run docs . See example below. \"scripts\":{ \"docs\": \"xt-docs\" } Configuration By default the CLI will look for docs configuration in two different places: - in package.json using key xtdocs - in a file named .xtdocs.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with -c ( --config ) flag, followed by path to file. See commands for an example . Minimum Project-Level Configuration Within the extension project you should define, at minimum, the following configuration options: \"xtdocs\": { \"templates\": { \"systemName\": \"{extension name}\", \"systemSummary\": \"{short description}\", \"systemColor\": \"{css-color}\" } } where: key Description of value systemName Name of you project systemSummary Provide a short description of your project; this will be shown as a subheading in the generated docs systemColor Choose a theme color for your documentation; css hex color definition will work, e.g. #000000 . Default Configuration The CLI uses a documentation configuration file shown below. You can override any of these key-value pairs at project level. You can also add key-value pairs that are not defined here so long as they are intelligible to JSDoc . \"xtdocs\": { \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [ \"jsdoc\" ] }, \"source\": { \"include\": [ \"src\" ], \"includePattern\": \".js$\", \"excludePattern\": \"(node_modules/|docs)\" }, \"plugins\": [ \"plugins/markdown\" ], \"templates\": { \"footer\": \"\", \"copyright\": \"\", \"includeDate\": \"true\", \"dateFormat\": \"MMM YYYY\", \"inlineNav\": \"true\", \"inverseNav\": \"false\", \"linenums\": \"true\", \"showTableOfContents\": \"true\", \"showAccessFilter\": \"true\", \"collapseSymbols\": \"true\", \"methodHeadingReturns\": \"false\", \"outputSourceFiles\": \"true\", \"outputSourcePath\": \"true\", \"search\": \"true\", \"stylesheets\": [ \"data:text/css;base64,Zm9vdGVyewogICAgZGlzcGxheTpub25lIWltcG9ydGFudDsKfQ==\" ], \"scripts\": [], \"favicon\": \"./assets/img/128x128.png\" }, \"opts\": { \"destination\": \"./public/documentation\", \"encoding\": \"utf8\", \"private\": true, \"recurse\": true, \"template\": \"./node_modules/foodoc/template\" } } Templates templates key is used specifically to customize the options for a template of choice. This is useful if you want to change the look and feel of the generated documentation. The default template used by this CLI is Foodoc . You can change the template by overriding opts.template in the project-level configuration, and by adding the template package of your choice to project-level dependencies. This list can help you get started with picking a custom template. If you cannot find one that you like, you can always make and publish your own. This documentation you are reading currently was generated using JSDoc and Foodoc theme.","title":"xt-docs"},{"location":"guide/xt-docs/#xt-docs","text":"xt-docs command is used for generating source code documentation for an extension project. Extension CLI uses JSDoc 3 specification to generate documentation for javascript files in an extension project. JSDoc is a flexible documentation generator that converts javascript code comments to readable HTML/CSS files which you can be hosted for example with github pages. You can use any compatible template of choice to skin your docs. Learn more about templating here .","title":"xt-docs"},{"location":"guide/xt-docs/#commands","text":"Default command xt-docs Command using custom configuration file path xt-docs --config \"/path/to/config.json\" Get help using this command xt-docs --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-docs . Or you can add an option to packages.json scripts section and then execute the command as npm run docs . See example below. \"scripts\":{ \"docs\": \"xt-docs\" }","title":"Commands"},{"location":"guide/xt-docs/#configuration","text":"By default the CLI will look for docs configuration in two different places: - in package.json using key xtdocs - in a file named .xtdocs.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with -c ( --config ) flag, followed by path to file. See commands for an example .","title":"Configuration"},{"location":"guide/xt-docs/#minimum-project-level-configuration","text":"Within the extension project you should define, at minimum, the following configuration options: \"xtdocs\": { \"templates\": { \"systemName\": \"{extension name}\", \"systemSummary\": \"{short description}\", \"systemColor\": \"{css-color}\" } } where: key Description of value systemName Name of you project systemSummary Provide a short description of your project; this will be shown as a subheading in the generated docs systemColor Choose a theme color for your documentation; css hex color definition will work, e.g. #000000 .","title":"Minimum Project-Level Configuration"},{"location":"guide/xt-docs/#default-configuration","text":"The CLI uses a documentation configuration file shown below. You can override any of these key-value pairs at project level. You can also add key-value pairs that are not defined here so long as they are intelligible to JSDoc . \"xtdocs\": { \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [ \"jsdoc\" ] }, \"source\": { \"include\": [ \"src\" ], \"includePattern\": \".js$\", \"excludePattern\": \"(node_modules/|docs)\" }, \"plugins\": [ \"plugins/markdown\" ], \"templates\": { \"footer\": \"\", \"copyright\": \"\", \"includeDate\": \"true\", \"dateFormat\": \"MMM YYYY\", \"inlineNav\": \"true\", \"inverseNav\": \"false\", \"linenums\": \"true\", \"showTableOfContents\": \"true\", \"showAccessFilter\": \"true\", \"collapseSymbols\": \"true\", \"methodHeadingReturns\": \"false\", \"outputSourceFiles\": \"true\", \"outputSourcePath\": \"true\", \"search\": \"true\", \"stylesheets\": [ \"data:text/css;base64,Zm9vdGVyewogICAgZGlzcGxheTpub25lIWltcG9ydGFudDsKfQ==\" ], \"scripts\": [], \"favicon\": \"./assets/img/128x128.png\" }, \"opts\": { \"destination\": \"./public/documentation\", \"encoding\": \"utf8\", \"private\": true, \"recurse\": true, \"template\": \"./node_modules/foodoc/template\" } }","title":"Default Configuration"},{"location":"guide/xt-docs/#templates","text":"templates key is used specifically to customize the options for a template of choice. This is useful if you want to change the look and feel of the generated documentation. The default template used by this CLI is Foodoc . You can change the template by overriding opts.template in the project-level configuration, and by adding the template package of your choice to project-level dependencies. This list can help you get started with picking a custom template. If you cannot find one that you like, you can always make and publish your own. This documentation you are reading currently was generated using JSDoc and Foodoc theme.","title":"Templates"},{"location":"guide/xt-sync/","text":"xt-sync xt-sync command is intended for upgrading configuration files of a stale project to the latest versions When a project has not been worked on recently, it may need updates of various files, such as CI configuration files. The purpose of this command is to make that update process simple by allowing each project to choose which configuration files to update. The CLI will then supply the project with the most recent configuration files. Note: If the configuration files have been modified heavily for an individual project, it is not advisable to upgrade them in this manner. Instead you should upgrade such configuration files manually. Commands You must pass at least one flag with this command. Synchronize all configuration files xt-sync --all Synchronize ESLint configuration file xt-sync --eslint Synchronize Gitlab CI configuration file xt-sync --gitlab Synchronize Travis CI configuration file xt-sync --travis Synchronize .gitignore file xt-sync --gitignore Get help using this command xt-sync --help After installing extension-cli, you can run these commands from a terminal using npx xt-sync --all . Or you can add an option to packages.json scripts section and then execute the command as npm run sync . See example below. \"scripts\":{ \"sync\": \"xt-sync --all\" }","title":"xt-sync"},{"location":"guide/xt-sync/#xt-sync","text":"xt-sync command is intended for upgrading configuration files of a stale project to the latest versions When a project has not been worked on recently, it may need updates of various files, such as CI configuration files. The purpose of this command is to make that update process simple by allowing each project to choose which configuration files to update. The CLI will then supply the project with the most recent configuration files. Note: If the configuration files have been modified heavily for an individual project, it is not advisable to upgrade them in this manner. Instead you should upgrade such configuration files manually.","title":"xt-sync"},{"location":"guide/xt-sync/#commands","text":"You must pass at least one flag with this command. Synchronize all configuration files xt-sync --all Synchronize ESLint configuration file xt-sync --eslint Synchronize Gitlab CI configuration file xt-sync --gitlab Synchronize Travis CI configuration file xt-sync --travis Synchronize .gitignore file xt-sync --gitignore Get help using this command xt-sync --help After installing extension-cli, you can run these commands from a terminal using npx xt-sync --all . Or you can add an option to packages.json scripts section and then execute the command as npm run sync . See example below. \"scripts\":{ \"sync\": \"xt-sync --all\" }","title":"Commands"},{"location":"guide/xt-test/","text":"xt-test xt-test command will run unit tests located in test/ directory. This command will setup extension testing environment that is pre-initialized with mocha , chai (including chai-as-promised), and expect. nyc is used for computing code coverage. Also the following browser features are initialized: window, chrome. Window is setup using jsdom-global and chrome using sinon-chrome . This command will look for tests in test/ directory, in any file ending with .js . Mocha will execute with babel, meaning you can use this test environment with ES6 modules. You may extend this test environment within an extension project; this is simply the base setup for running unit tests. Or you may create your own test environment if this is not suitable. Commands Default command: run unit tests xt-test Execute tests and keep watching changes xt-test --watch Execute tests and pipe result to coveralls.io xt-test --coverage Get help using this command xt-test --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-test . Or you can add an option to packages.json scripts section and then execute the command as npm run test . See example below. \"scripts\":{ \"test\": \"xt-test\" }","title":"xt-test"},{"location":"guide/xt-test/#xt-test","text":"xt-test command will run unit tests located in test/ directory. This command will setup extension testing environment that is pre-initialized with mocha , chai (including chai-as-promised), and expect. nyc is used for computing code coverage. Also the following browser features are initialized: window, chrome. Window is setup using jsdom-global and chrome using sinon-chrome . This command will look for tests in test/ directory, in any file ending with .js . Mocha will execute with babel, meaning you can use this test environment with ES6 modules. You may extend this test environment within an extension project; this is simply the base setup for running unit tests. Or you may create your own test environment if this is not suitable.","title":"xt-test"},{"location":"guide/xt-test/#commands","text":"Default command: run unit tests xt-test Execute tests and keep watching changes xt-test --watch Execute tests and pipe result to coveralls.io xt-test --coverage Get help using this command xt-test --help After installing extension-cli, you can run these commands from a terminal using syntax npx xt-test . Or you can add an option to packages.json scripts section and then execute the command as npm run test . See example below. \"scripts\":{ \"test\": \"xt-test\" }","title":"Commands"}]}