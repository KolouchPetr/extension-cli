{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Extension CLI Extension CLI provides command-line build tools that facilitate rapid chrome extension development by providing systematic way to build, test and document extension projects. Getting Started & Docs Create a new extension project: npx extension-cli Add CLI to an existing project: npm install extension-cli Quick Command Reference Command Description xt-build Run builds; env flags: -e prod and -e dev xt-test Run unit tests xt-docs Generate docs xt-sync Update project config files to match the latest defaults supplied by this CLI xt-clean Remove automatically generated files Note that for each command --help and --version flags are also valid Read these docs for more detailed guides! Extension CLI is made with \ud83c\udf51 by Mobile First in Augusta, Georgia Star Fork Issue Watch","title":"Hello World"},{"location":"#extension-cli","text":"Extension CLI provides command-line build tools that facilitate rapid chrome extension development by providing systematic way to build, test and document extension projects.","title":"Extension CLI"},{"location":"#getting-started-docs","text":"Create a new extension project: npx extension-cli Add CLI to an existing project: npm install extension-cli","title":"Getting Started &amp; Docs"},{"location":"#quick-command-reference","text":"Command Description xt-build Run builds; env flags: -e prod and -e dev xt-test Run unit tests xt-docs Generate docs xt-sync Update project config files to match the latest defaults supplied by this CLI xt-clean Remove automatically generated files Note that for each command --help and --version flags are also valid Read these docs for more detailed guides! Extension CLI is made with \ud83c\udf51 by Mobile First in Augusta, Georgia Star Fork Issue Watch","title":"Quick Command Reference"},{"location":"01-getting-started/","text":"Installation Prerequisites Before using extension CLI, you should have all of the following: Node.js Any web-friendly IDE Terminal/cmd access Chrome browser for debugging extensions Setup Create a new extension project: npx extension-cli Add CLI to an existing project: npm install extension-cli Default Project Organization Before you start using the CLI, inspect your project file structure. You can override most of these paths in configurations, but this organization matches the CLI defaults. If you created a new extension using the command above, your file structure already looks like this. Path Description \u2514 assets static assets \u2514\u2500 img Extension icons \u2514\u2500 locales Localized string resources \u2514\u2500 en/messages.json English dictionary \u2514 src Source code: put js, scss, html, json files here \u2514\u2500 manifest.json Extension manifest \u2514 test Unit tests \u2514 package.json Application root","title":"Installation"},{"location":"01-getting-started/#installation","text":"","title":"Installation"},{"location":"01-getting-started/#prerequisites","text":"Before using extension CLI, you should have all of the following: Node.js Any web-friendly IDE Terminal/cmd access Chrome browser for debugging extensions","title":"Prerequisites"},{"location":"01-getting-started/#setup","text":"Create a new extension project: npx extension-cli Add CLI to an existing project: npm install extension-cli","title":"Setup"},{"location":"01-getting-started/#default-project-organization","text":"Before you start using the CLI, inspect your project file structure. You can override most of these paths in configurations, but this organization matches the CLI defaults. If you created a new extension using the command above, your file structure already looks like this. Path Description \u2514 assets static assets \u2514\u2500 img Extension icons \u2514\u2500 locales Localized string resources \u2514\u2500 en/messages.json English dictionary \u2514 src Source code: put js, scss, html, json files here \u2514\u2500 manifest.json Extension manifest \u2514 test Unit tests \u2514 package.json Application root","title":"Default Project Organization"},{"location":"02-configuration/","text":"Configuration for Existing Applications If you created the extension with Extension CLI, this setup is already done for you, and you may skip this step. For an existing application, before using Extension CLI, add these configuration options to package.json : Babel Presets This is needed to compile projects written in ES6. \"babel\": { \"presets\": [ \"@babel/preset-env\" ] } ESLint Ignore Exclude test files from being linted. If your project includes compiled 3rd party libraries, you should exclude them also. \"eslintIgnore\": [ \"test/**/*\" ] Add Scripts Add these scripts to package.json then you can run, for example, npm run start . \"scripts\": { \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", \"clean\": \"xt-clean\", \"docs\": \"xt-docs\", \"test\": \"xt-test\" }","title":"Configuration"},{"location":"02-configuration/#configuration-for-existing-applications","text":"If you created the extension with Extension CLI, this setup is already done for you, and you may skip this step. For an existing application, before using Extension CLI, add these configuration options to package.json :","title":"Configuration for Existing Applications"},{"location":"02-configuration/#babel-presets","text":"This is needed to compile projects written in ES6. \"babel\": { \"presets\": [ \"@babel/preset-env\" ] }","title":"Babel Presets"},{"location":"02-configuration/#eslint-ignore","text":"Exclude test files from being linted. If your project includes compiled 3rd party libraries, you should exclude them also. \"eslintIgnore\": [ \"test/**/*\" ]","title":"ESLint Ignore"},{"location":"02-configuration/#add-scripts","text":"Add these scripts to package.json then you can run, for example, npm run start . \"scripts\": { \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", \"clean\": \"xt-clean\", \"docs\": \"xt-docs\", \"test\": \"xt-test\" }","title":"Add Scripts"},{"location":"03-xt-build/","text":"xt-build xt-build command is used for generating a debuggable, development version of an extension project. It is also used to create a production-ready, minified .zip file that can be uploaded to the chrome web store. Successful build command always generates an extension dist/ directory that can be debugged in the browser. The underlying build system uses gulp , babel and webpack to compile scripts (among other plugins). Dev Build Artifacts When specifying dev build flag, the build will complete using development settings. The output of a successful dev build is a dist/ directory which can be debugged using the chrome browser. The build command will always compile scripts using production settings, because extension scripts must be compiled prior to debugging ( eval is not allowed). Prod Build Artifacts When specifying prod build flag, the build will run a production build. Successful production build will generate a dist/ directory of extension files which can be debugged in the browser. It will also generate a release.zip file in the project root strictly based on the files in the dist directory. This zip file can be uploaded directly to the Chrome Web Store. When running a production build, all code files (js, sass, html, json) will be minified. Commands Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Run production build (default) xt-build Run production build using explicit flag -e or --env xt-build {-e|--env} prod Run development build xt-build {-e|--env} dev Run command using custom configuration file path xt-build {-c|--config} \"/path/to/config.json\" Run development build and keep watching changes xt-build {-e|--env} dev {-w|--watch} Get help using this command xt-build --help Package.json scripts After adding Extension CLI to your project, you can run these commands from a terminal using syntax npx xt-build . Or you can add an option to packages.json scripts section as shown below, and then execute the command as npm run build or npm run start . \"scripts\":{ \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", } Build Configuration By default the CLI will look for build configuration in two different places: in package.json using key xtbuild in a file named .xtbuild.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with -c or --config flag, followed by path to file. See commands for an example . The CLI uses a default build configuration file shown below. This tells the extension CLI where to look for files and where to output files. You can override any of these key-value pairs at project level. You can find more detailed explanations of usage of some of these keys below . { \"projectRootDir\": \"../../../\", \"dist\": \"./dist\", \"source\": \"./src\", \"releases\": \"./\", \"manifest\": \"./src/manifest.json\", \"js\": \"./src/**/*.js\", \"js_bundles\": null, \"html\": \"./src/**/*.html\", \"scss\": \"./src/**/*.scss\", \"scss_bundles\": null, \"icons\":[ images, images, images, images ], \"copyAsIs\": [], \"locales_dir\": \"./assets/locales/\", \"locales_list\": [\"en\"] } Custom Configurations Script Bundles js_bundles key used to configure build settings for javascript bundles. You will need to configure bundles when your compiled extension contains more than 1 javascript file. The expected value for js_bundles is an array with one or more items as shown in the example below. name is the output bundle filename without file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). Example Sample project-level configuration with multiple javascript bundles. This configuration will produce two javascript files in the /dist directory. One file contains exactly src/background.js and One file contains all .js files under scr/app/dir1 and scr/app/dir2 \"xtbuild\": { \"js_bundles\": [ { \"name\": \"background\", \"src\": \"./src/background.js\" }, { \"name\": \"app\", \"src\": [ \"./src/app/dir1/**/*.js\", \"./src/app/dir2/**/*.js\" ] } ] } Skip Javascript Compilation and Linting Use copyAsIs key to specify an array of files which should not be compiled. These files can be located anywhere in your project, but probably best to store them somewhere outside /src directory. The build command will copy specified files exactly without any modification to the root of the output directory. Directory path will be flattened. Example Sample configuration for skipping compilation of pre-compiled files. This configuration will copy material theme directly from node modules and include it in the dist directory. It will also copy a project level ga.js script in the dist directory. No modification will occur to these files during the build step. \"xtbuild\": { \"copyAsIs\": [ \"./node_modules/material-design-lite/material.min.js\", \"./assets/ga.js\" ] } Note that when you include precompiled javascript files to your extension project, you should also disable linting for those files. In the project-level package.json , add the file paths to the list of ignored files to prevent them from being linted. { \"eslintIgnore\": [ \"test/**/*\", \"./assets/ga.js\" ] } Style bundles scss_bundles are used to configure build settings for css-style files. The expected value is an array with one or more items as shown in the example below. The property value name is the output bundle filename with file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). The production build will minify style files. Dev build does not minify style files. By default, the stylesheets are assumed to be written using Sass . If you are not a friend of Sass language stylesheets, you can write your style sheets using regular CSS. Any CSS you write is valid Sass as well. When you name stylesheet files, use .scss file extension. The default CLI configuration looks for this file extension. Otherwise you must override this default configuration: \"scss\": \"./src/**/*.scss\" to include other file extensions in the style bundles. Example Sample project-level configuration with multiple style bundles \"xtbuild\": { \"scss_bundles\": [ { \"src\": [ \"./src/**/*.scss\", \"!./src/app/styles/message.scss\" ], \"name\": \"styles.css\" }, { \"src\": [ \"./src/app/styles/message.scss\" ], \"name\": \"display.css\" } ] } Text Localization If the extension supports multiple languages, specify all supported languages using key locales_list . The default language value is [\"en\"] . This locales_list should be an array that corresponds to a list of subdirectories under locales_dir in the extension project. The default locales_dir is ./assets/locales/ , which you may change if you want. Refer to this list of language codes when naming individual language directories. Also read this guide to learn how to internationalize extensions . Example Multiple locales example with custom path to locales files \"xtbuild\": { \"locales_dir\": \"./my/custom/locales/path/\", \"locales_list\": [\"en\",\"en-GB\",\"pl\"] } The configuration above translates to the following project-level directory structure: File Path Description \u2514 /my/custom/locales/path/ path to locales \u2514\u2500 en /messages.json Default English dictionary \u2514\u2500 en-GB /myFile.json British dictionary \u2514\u2500 pl/ Polish language dictionaries \u2514\u2500 app.json Polish language dictionaries \u2514\u2500 options.json Polish language dictionaries You can break down your locales files into multiple .json files within the language-specific directory as shown in the example above for pl/ . This may make the maintenance locales files easier if the files contain multiple entries. The build step will automatically combine all files within a language directory into a single messages.json which is expected from a browser extensions. Image Assets By default extension CLI will look for image assets using these configurations: \"icons\": [ \"./assets/img/**/*.png\", \"./assets/img/**/*.gif\", \"./assets/img/**/*.jpg\", \"./assets/img/**/*.svg\" ], You may change this configuration if the project image assets are located elsewhere or if you want to support additional image file extensions. After the build step, all image assets will be located in the /dist/icons directory. Therefore, in your extension project manifest.json you would refer to them as follows: \"browser_action\": { \"default_icon\": { \"16\": \"icons/16x16.png\", \"24\": \"icons/24x24.png\", \"32\": \"icons/32x32.png\" } }","title":"xt-build"},{"location":"03-xt-build/#xt-build","text":"xt-build command is used for generating a debuggable, development version of an extension project. It is also used to create a production-ready, minified .zip file that can be uploaded to the chrome web store. Successful build command always generates an extension dist/ directory that can be debugged in the browser. The underlying build system uses gulp , babel and webpack to compile scripts (among other plugins).","title":"xt-build"},{"location":"03-xt-build/#dev-build-artifacts","text":"When specifying dev build flag, the build will complete using development settings. The output of a successful dev build is a dist/ directory which can be debugged using the chrome browser. The build command will always compile scripts using production settings, because extension scripts must be compiled prior to debugging ( eval is not allowed).","title":"Dev Build Artifacts"},{"location":"03-xt-build/#prod-build-artifacts","text":"When specifying prod build flag, the build will run a production build. Successful production build will generate a dist/ directory of extension files which can be debugged in the browser. It will also generate a release.zip file in the project root strictly based on the files in the dist directory. This zip file can be uploaded directly to the Chrome Web Store. When running a production build, all code files (js, sass, html, json) will be minified.","title":"Prod Build Artifacts"},{"location":"03-xt-build/#commands","text":"Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Run production build (default) xt-build Run production build using explicit flag -e or --env xt-build {-e|--env} prod Run development build xt-build {-e|--env} dev Run command using custom configuration file path xt-build {-c|--config} \"/path/to/config.json\" Run development build and keep watching changes xt-build {-e|--env} dev {-w|--watch} Get help using this command xt-build --help","title":"Commands"},{"location":"03-xt-build/#packagejson-scripts","text":"After adding Extension CLI to your project, you can run these commands from a terminal using syntax npx xt-build . Or you can add an option to packages.json scripts section as shown below, and then execute the command as npm run build or npm run start . \"scripts\":{ \"start\": \"xt-build -e dev -w\", \"build\": \"xt-build -e prod\", }","title":"Package.json scripts"},{"location":"03-xt-build/#build-configuration","text":"By default the CLI will look for build configuration in two different places: in package.json using key xtbuild in a file named .xtbuild.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with -c or --config flag, followed by path to file. See commands for an example . The CLI uses a default build configuration file shown below. This tells the extension CLI where to look for files and where to output files. You can override any of these key-value pairs at project level. You can find more detailed explanations of usage of some of these keys below . { \"projectRootDir\": \"../../../\", \"dist\": \"./dist\", \"source\": \"./src\", \"releases\": \"./\", \"manifest\": \"./src/manifest.json\", \"js\": \"./src/**/*.js\", \"js_bundles\": null, \"html\": \"./src/**/*.html\", \"scss\": \"./src/**/*.scss\", \"scss_bundles\": null, \"icons\":[ images, images, images, images ], \"copyAsIs\": [], \"locales_dir\": \"./assets/locales/\", \"locales_list\": [\"en\"] }","title":"Build Configuration"},{"location":"03-xt-build/#custom-configurations","text":"","title":"Custom Configurations"},{"location":"03-xt-build/#script-bundles","text":"js_bundles key used to configure build settings for javascript bundles. You will need to configure bundles when your compiled extension contains more than 1 javascript file. The expected value for js_bundles is an array with one or more items as shown in the example below. name is the output bundle filename without file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). Example Sample project-level configuration with multiple javascript bundles. This configuration will produce two javascript files in the /dist directory. One file contains exactly src/background.js and One file contains all .js files under scr/app/dir1 and scr/app/dir2 \"xtbuild\": { \"js_bundles\": [ { \"name\": \"background\", \"src\": \"./src/background.js\" }, { \"name\": \"app\", \"src\": [ \"./src/app/dir1/**/*.js\", \"./src/app/dir2/**/*.js\" ] } ] }","title":"Script Bundles"},{"location":"03-xt-build/#skip-javascript-compilation-and-linting","text":"Use copyAsIs key to specify an array of files which should not be compiled. These files can be located anywhere in your project, but probably best to store them somewhere outside /src directory. The build command will copy specified files exactly without any modification to the root of the output directory. Directory path will be flattened. Example Sample configuration for skipping compilation of pre-compiled files. This configuration will copy material theme directly from node modules and include it in the dist directory. It will also copy a project level ga.js script in the dist directory. No modification will occur to these files during the build step. \"xtbuild\": { \"copyAsIs\": [ \"./node_modules/material-design-lite/material.min.js\", \"./assets/ga.js\" ] } Note that when you include precompiled javascript files to your extension project, you should also disable linting for those files. In the project-level package.json , add the file paths to the list of ignored files to prevent them from being linted. { \"eslintIgnore\": [ \"test/**/*\", \"./assets/ga.js\" ] }","title":"Skip Javascript Compilation and Linting"},{"location":"03-xt-build/#style-bundles","text":"scss_bundles are used to configure build settings for css-style files. The expected value is an array with one or more items as shown in the example below. The property value name is the output bundle filename with file extension src specifies which files to include in each bundle; you can use a string value for a single file, array of files, or a path with wildcard. You may also use ! as a way to negate the inclusion of a file. This is the globs syntax expected by gulp (without options). The production build will minify style files. Dev build does not minify style files. By default, the stylesheets are assumed to be written using Sass . If you are not a friend of Sass language stylesheets, you can write your style sheets using regular CSS. Any CSS you write is valid Sass as well. When you name stylesheet files, use .scss file extension. The default CLI configuration looks for this file extension. Otherwise you must override this default configuration: \"scss\": \"./src/**/*.scss\" to include other file extensions in the style bundles. Example Sample project-level configuration with multiple style bundles \"xtbuild\": { \"scss_bundles\": [ { \"src\": [ \"./src/**/*.scss\", \"!./src/app/styles/message.scss\" ], \"name\": \"styles.css\" }, { \"src\": [ \"./src/app/styles/message.scss\" ], \"name\": \"display.css\" } ] }","title":"Style bundles"},{"location":"03-xt-build/#text-localization","text":"If the extension supports multiple languages, specify all supported languages using key locales_list . The default language value is [\"en\"] . This locales_list should be an array that corresponds to a list of subdirectories under locales_dir in the extension project. The default locales_dir is ./assets/locales/ , which you may change if you want. Refer to this list of language codes when naming individual language directories. Also read this guide to learn how to internationalize extensions . Example Multiple locales example with custom path to locales files \"xtbuild\": { \"locales_dir\": \"./my/custom/locales/path/\", \"locales_list\": [\"en\",\"en-GB\",\"pl\"] } The configuration above translates to the following project-level directory structure: File Path Description \u2514 /my/custom/locales/path/ path to locales \u2514\u2500 en /messages.json Default English dictionary \u2514\u2500 en-GB /myFile.json British dictionary \u2514\u2500 pl/ Polish language dictionaries \u2514\u2500 app.json Polish language dictionaries \u2514\u2500 options.json Polish language dictionaries You can break down your locales files into multiple .json files within the language-specific directory as shown in the example above for pl/ . This may make the maintenance locales files easier if the files contain multiple entries. The build step will automatically combine all files within a language directory into a single messages.json which is expected from a browser extensions.","title":"Text Localization"},{"location":"03-xt-build/#image-assets","text":"By default extension CLI will look for image assets using these configurations: \"icons\": [ \"./assets/img/**/*.png\", \"./assets/img/**/*.gif\", \"./assets/img/**/*.jpg\", \"./assets/img/**/*.svg\" ], You may change this configuration if the project image assets are located elsewhere or if you want to support additional image file extensions. After the build step, all image assets will be located in the /dist/icons directory. Therefore, in your extension project manifest.json you would refer to them as follows: \"browser_action\": { \"default_icon\": { \"16\": \"icons/16x16.png\", \"24\": \"icons/24x24.png\", \"32\": \"icons/32x32.png\" } }","title":"Image Assets"},{"location":"04-xt-clean/","text":"xt-clean xt-clean command removes all automatically generated files from the project directories. Clean operation iterates over files and directories listed in the project .gitignore file, and removes all ignored files and directories, except node_modules/ , .idea/ , and .vscode/ . .idea is a collection of configuration files used by WebStorm IDE, and .vscode is the same for Visual Studio Code. The IDE will generate them automatically if they are absent. To remove these three directories, you must explicitly pass a flag to delete each directory respectively. Commands Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Remove ignored files (default) xt-clean Clear ignored files, including node_modules xt-clean {-m|--modules} Clear ignored files, including .idea/ directory xt-clean {-i|--idea} Clear ignored files, including .vscode/ directory xt-clean {-v|--vscode} Clear absolutely all ignored files xt-clean -v -i -m Get help using this command xt-clean --help Package.json scripts After installing extension-cli, you can run these commands from a terminal using syntax npx xt-clean . Or you can add an option to packages.json scripts section and then execute the command as npm run clean See example below. \"scripts\":{ \"clean\": \"xt-clean\" }","title":"xt-clean"},{"location":"04-xt-clean/#xt-clean","text":"xt-clean command removes all automatically generated files from the project directories. Clean operation iterates over files and directories listed in the project .gitignore file, and removes all ignored files and directories, except node_modules/ , .idea/ , and .vscode/ . .idea is a collection of configuration files used by WebStorm IDE, and .vscode is the same for Visual Studio Code. The IDE will generate them automatically if they are absent. To remove these three directories, you must explicitly pass a flag to delete each directory respectively.","title":"xt-clean"},{"location":"04-xt-clean/#commands","text":"Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Remove ignored files (default) xt-clean Clear ignored files, including node_modules xt-clean {-m|--modules} Clear ignored files, including .idea/ directory xt-clean {-i|--idea} Clear ignored files, including .vscode/ directory xt-clean {-v|--vscode} Clear absolutely all ignored files xt-clean -v -i -m Get help using this command xt-clean --help","title":"Commands"},{"location":"04-xt-clean/#packagejson-scripts","text":"After installing extension-cli, you can run these commands from a terminal using syntax npx xt-clean . Or you can add an option to packages.json scripts section and then execute the command as npm run clean See example below. \"scripts\":{ \"clean\": \"xt-clean\" }","title":"Package.json scripts"},{"location":"05-xt-docs/","text":"xt-docs xt-docs command is used for generating source code documentation for an extension project. Extension CLI uses JSDoc specification to generate documentation for javascript files in an extension project. JSDoc is a flexible documentation generator that converts javascript code comments to readable HTML/CSS files which you can be hosted for example with github pages. You can use any compatible template of choice to skin your docs. Learn more about templating here . Commands Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Default command xt-docs Command using custom configuration file path xt-docs {-c|--config} \"/path/to/config.json\" Get help using this command xt-docs --help Package.json scripts After installing extension-cli, you can run these commands from a terminal using syntax npx xt-docs . Or you can add an option to packages.json scripts section and then execute the command as npm run docs . See example below. \"scripts\":{ \"docs\": \"xt-docs\" } Configuration By default the CLI will look for docs configuration in two different places: in package.json using key xtdocs in a file named .xtdocs.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with -c ( --config ) flag, followed by path to file. See commands for an example . Minimum Project-Level Configuration Within the extension project you should define, at minimum, the following configuration options: \"xtdocs\": { \"templates\": { \"systemName\": \"{extension name}\", \"systemSummary\": \"{short description}\", \"systemColor\": \"{css-color}\" } } where: key Description of value systemName Name of you project systemSummary Provide a short description of your project; this will be shown as a subheading in the generated docs systemColor Choose a theme color for your documentation; css hex color definition will work, e.g. #000000 . Default Configuration The CLI uses a documentation configuration file shown below. You can override any of these key-value pairs at project level. You can also add key-value pairs that are not defined here so long as they follow to JSDoc guidelines . \"xtdocs\": { \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [ \"jsdoc\" ] }, \"source\": { \"include\": [ \"src\" ], \"includePattern\": \".js$\", \"excludePattern\": \"(node_modules/|docs)\" }, \"plugins\": [ \"plugins/markdown\" ], \"templates\": { \"footer\": \"\", \"copyright\": \"\", \"includeDate\": \"true\", \"dateFormat\": \"MMM YYYY\", \"inlineNav\": \"true\", \"inverseNav\": \"false\", \"linenums\": \"true\", \"showTableOfContents\": \"true\", \"showAccessFilter\": \"true\", \"collapseSymbols\": \"true\", \"methodHeadingReturns\": \"false\", \"outputSourceFiles\": \"true\", \"outputSourcePath\": \"true\", \"search\": \"true\", \"stylesheets\": [ \"data:text/css;base64,Zm9vdGVyewogICAgZGlzcGxheTpub25lIWltcG9ydGFudDsKfQ==\" ], \"scripts\": [], \"favicon\": \"./assets/img/128x128.png\" }, \"opts\": { \"destination\": \"./public/documentation\", \"encoding\": \"utf8\", \"private\": true, \"recurse\": true, \"template\": \"./node_modules/foodoc/template\" } } Templates templates key is used specifically to customize the options for a template of choice. This is useful if you want to change the look and feel of the generated documentation. The default template used by this CLI is Foodoc . You can change the template by overriding opts.template in the project-level configuration, and by adding the template package of your choice to project-level dependencies. This list can help you get started with picking a custom template. If you cannot find one that you like, you can always make and publish your own.","title":"xt-docs"},{"location":"05-xt-docs/#xt-docs","text":"xt-docs command is used for generating source code documentation for an extension project. Extension CLI uses JSDoc specification to generate documentation for javascript files in an extension project. JSDoc is a flexible documentation generator that converts javascript code comments to readable HTML/CSS files which you can be hosted for example with github pages. You can use any compatible template of choice to skin your docs. Learn more about templating here .","title":"xt-docs"},{"location":"05-xt-docs/#commands","text":"Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Default command xt-docs Command using custom configuration file path xt-docs {-c|--config} \"/path/to/config.json\" Get help using this command xt-docs --help","title":"Commands"},{"location":"05-xt-docs/#packagejson-scripts","text":"After installing extension-cli, you can run these commands from a terminal using syntax npx xt-docs . Or you can add an option to packages.json scripts section and then execute the command as npm run docs . See example below. \"scripts\":{ \"docs\": \"xt-docs\" }","title":"Package.json scripts"},{"location":"05-xt-docs/#configuration","text":"By default the CLI will look for docs configuration in two different places: in package.json using key xtdocs in a file named .xtdocs.json in project root If these two locations cause a conflict, alternatively you can provide a path to configuration file with -c ( --config ) flag, followed by path to file. See commands for an example .","title":"Configuration"},{"location":"05-xt-docs/#minimum-project-level-configuration","text":"Within the extension project you should define, at minimum, the following configuration options: \"xtdocs\": { \"templates\": { \"systemName\": \"{extension name}\", \"systemSummary\": \"{short description}\", \"systemColor\": \"{css-color}\" } } where: key Description of value systemName Name of you project systemSummary Provide a short description of your project; this will be shown as a subheading in the generated docs systemColor Choose a theme color for your documentation; css hex color definition will work, e.g. #000000 .","title":"Minimum Project-Level Configuration"},{"location":"05-xt-docs/#default-configuration","text":"The CLI uses a documentation configuration file shown below. You can override any of these key-value pairs at project level. You can also add key-value pairs that are not defined here so long as they follow to JSDoc guidelines . \"xtdocs\": { \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [ \"jsdoc\" ] }, \"source\": { \"include\": [ \"src\" ], \"includePattern\": \".js$\", \"excludePattern\": \"(node_modules/|docs)\" }, \"plugins\": [ \"plugins/markdown\" ], \"templates\": { \"footer\": \"\", \"copyright\": \"\", \"includeDate\": \"true\", \"dateFormat\": \"MMM YYYY\", \"inlineNav\": \"true\", \"inverseNav\": \"false\", \"linenums\": \"true\", \"showTableOfContents\": \"true\", \"showAccessFilter\": \"true\", \"collapseSymbols\": \"true\", \"methodHeadingReturns\": \"false\", \"outputSourceFiles\": \"true\", \"outputSourcePath\": \"true\", \"search\": \"true\", \"stylesheets\": [ \"data:text/css;base64,Zm9vdGVyewogICAgZGlzcGxheTpub25lIWltcG9ydGFudDsKfQ==\" ], \"scripts\": [], \"favicon\": \"./assets/img/128x128.png\" }, \"opts\": { \"destination\": \"./public/documentation\", \"encoding\": \"utf8\", \"private\": true, \"recurse\": true, \"template\": \"./node_modules/foodoc/template\" } }","title":"Default Configuration"},{"location":"05-xt-docs/#templates","text":"templates key is used specifically to customize the options for a template of choice. This is useful if you want to change the look and feel of the generated documentation. The default template used by this CLI is Foodoc . You can change the template by overriding opts.template in the project-level configuration, and by adding the template package of your choice to project-level dependencies. This list can help you get started with picking a custom template. If you cannot find one that you like, you can always make and publish your own.","title":"Templates"},{"location":"06-xt-sync/","text":"xt-sync xt-sync command is intended for upgrading configuration files of a stale project to the latest versions When a project has not been worked on recently, it may need updates of various files, such as CI configuration files. The purpose of this command is to make that update process simple by allowing each project to choose which configuration files to update. The CLI will then supply the project with the most recent configuration files. Note: If the configuration files have been modified heavily for an individual project, it is not advisable to upgrade them in this manner. Instead you should upgrade such configuration files manually. Commands Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. You must pass at least one flag with this command. Synchronize all configuration files xt-sync {-a|--all} Synchronize ESLint configuration file xt-sync {-e|--eslint} Synchronize Gitlab CI configuration file xt-sync {-l|--gitlab} Synchronize Travis CI configuration file xt-sync {-t|--travis} Synchronize .gitignore file xt-sync {-g|--gitignore} Get help using this command xt-sync --help Package.json scripts After installing extension-cli, you can run these commands from a terminal using npx xt-sync --all . Or you can add an option to packages.json scripts section and then execute the command as npm run sync . See example below. \"scripts\":{ \"sync\": \"xt-sync --all\" }","title":"xt-sync"},{"location":"06-xt-sync/#xt-sync","text":"xt-sync command is intended for upgrading configuration files of a stale project to the latest versions When a project has not been worked on recently, it may need updates of various files, such as CI configuration files. The purpose of this command is to make that update process simple by allowing each project to choose which configuration files to update. The CLI will then supply the project with the most recent configuration files. Note: If the configuration files have been modified heavily for an individual project, it is not advisable to upgrade them in this manner. Instead you should upgrade such configuration files manually.","title":"xt-sync"},{"location":"06-xt-sync/#commands","text":"Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. You must pass at least one flag with this command. Synchronize all configuration files xt-sync {-a|--all} Synchronize ESLint configuration file xt-sync {-e|--eslint} Synchronize Gitlab CI configuration file xt-sync {-l|--gitlab} Synchronize Travis CI configuration file xt-sync {-t|--travis} Synchronize .gitignore file xt-sync {-g|--gitignore} Get help using this command xt-sync --help","title":"Commands"},{"location":"06-xt-sync/#packagejson-scripts","text":"After installing extension-cli, you can run these commands from a terminal using npx xt-sync --all . Or you can add an option to packages.json scripts section and then execute the command as npm run sync . See example below. \"scripts\":{ \"sync\": \"xt-sync --all\" }","title":"Package.json scripts"},{"location":"07-xt-test/","text":"xt-test xt-test command will run unit tests located in test/ directory. This command will setup extension testing environment that is pre-initialized with mocha , chai (including chai-as-promised), and expect. nyc is used for computing code coverage. Also the following browser features are initialized: window, chrome. Window is setup using jsdom-global and chrome using sinon-chrome . This command will look for tests in test/ directory, in any file ending with .js . Mocha will execute with babel, meaning you can use this test environment with ES6 modules. You may extend this test environment within an extension project; this is simply the base setup for running unit tests. Or you may create your own test environment if this is not suitable. Commands Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Run unit tests (default) xt-test Execute tests and keep watching changes xt-test {-w|--watch} Execute tests then pipe result to coveralls.io The default command will display coverage. Use this command explicitly to publish your coverage stats and track progress over time, for example during automated build. xt-test {-c|--coverage} Get help using this command xt-test --help Package.json scripts After installing extension-cli, you can run these commands from a terminal using syntax npx xt-test . Or you can add an option to packages.json scripts section and then execute the command as npm run test . See example below. \"scripts\":{ \"test\": \"xt-test\" }","title":"xt-test"},{"location":"07-xt-test/#xt-test","text":"xt-test command will run unit tests located in test/ directory. This command will setup extension testing environment that is pre-initialized with mocha , chai (including chai-as-promised), and expect. nyc is used for computing code coverage. Also the following browser features are initialized: window, chrome. Window is setup using jsdom-global and chrome using sinon-chrome . This command will look for tests in test/ directory, in any file ending with .js . Mocha will execute with babel, meaning you can use this test environment with ES6 modules. You may extend this test environment within an extension project; this is simply the base setup for running unit tests. Or you may create your own test environment if this is not suitable.","title":"xt-test"},{"location":"07-xt-test/#commands","text":"Braces { } indicate that the user must choose one \u2014 and only one \u2014 of the items inside the braces. Run unit tests (default) xt-test Execute tests and keep watching changes xt-test {-w|--watch} Execute tests then pipe result to coveralls.io The default command will display coverage. Use this command explicitly to publish your coverage stats and track progress over time, for example during automated build. xt-test {-c|--coverage} Get help using this command xt-test --help","title":"Commands"},{"location":"07-xt-test/#packagejson-scripts","text":"After installing extension-cli, you can run these commands from a terminal using syntax npx xt-test . Or you can add an option to packages.json scripts section and then execute the command as npm run test . See example below. \"scripts\":{ \"test\": \"xt-test\" }","title":"Package.json scripts"},{"location":"08-xt-create/","text":"extension-cli extension-cli command is used to create a new extension project. Commands npx extension-cli This command will prompt you with necessary questions. You do not need to call it with any arguments. This command will generate initial files and directories for a new project. Run it in the directory where you want to create the extension.","title":"extension-cli"},{"location":"08-xt-create/#extension-cli","text":"extension-cli command is used to create a new extension project.","title":"extension-cli"},{"location":"08-xt-create/#commands","text":"npx extension-cli This command will prompt you with necessary questions. You do not need to call it with any arguments. This command will generate initial files and directories for a new project. Run it in the directory where you want to create the extension.","title":"Commands"},{"location":"09-release-notes/","text":"Release Notes 0.8.9 (2020-04-10) Implemented command to create new extension Updated docs to reflect this new command 0.8.8 (2020-04-08) Upgraded project dependencies 0.8.7 (2020-01-17) Upgraded project dependencies Fixed scripts build step (changed webpack options) 0.8.6 (2019-12-21) Initial release for this publisher Migrated project from older source code Upgraded all packages Migrated build to use Gulp v4","title":"Release Notes"},{"location":"09-release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"09-release-notes/#089-2020-04-10","text":"Implemented command to create new extension Updated docs to reflect this new command","title":"0.8.9 (2020-04-10)"},{"location":"09-release-notes/#088-2020-04-08","text":"Upgraded project dependencies","title":"0.8.8 (2020-04-08)"},{"location":"09-release-notes/#087-2020-01-17","text":"Upgraded project dependencies Fixed scripts build step (changed webpack options)","title":"0.8.7 (2020-01-17)"},{"location":"09-release-notes/#086-2019-12-21","text":"Initial release for this publisher Migrated project from older source code Upgraded all packages Migrated build to use Gulp v4","title":"0.8.6 (2019-12-21)"},{"location":"10-showcase/","text":"List of Projects Alphabetical list by app name Name Maker Badge Download All Images Mobile First Sitemap Generator nkrusch Open Source Projects on Github See Dependency Graph Add your own project! Edit this file on Github to add your project, then submit a PR","title":"Showcase"},{"location":"10-showcase/#list-of-projects","text":"Alphabetical list by app name Name Maker Badge Download All Images Mobile First Sitemap Generator nkrusch","title":"List of Projects"},{"location":"10-showcase/#open-source-projects-on-github","text":"See Dependency Graph","title":"Open Source Projects on Github"},{"location":"10-showcase/#add-your-own-project","text":"Edit this file on Github to add your project, then submit a PR","title":"Add your own project!"},{"location":"11-stack/","text":"Tech Stack Extension CLI is built primarily with these tools: Tech Stack Node.js Gulp Chalk Commander Babel Chai Mocha ESLint jsdom JSDoc prompts Sinon Sinon-chrome NYC Webpack CLI Spinner yargs Source hosted on Github Published on NPM Documentation MkDocs MkDocs material theme Built with Travis CI Served by Github Pages","title":"Tech Stack"},{"location":"11-stack/#tech-stack","text":"Extension CLI is built primarily with these tools: Tech Stack Node.js Gulp Chalk Commander Babel Chai Mocha ESLint jsdom JSDoc prompts Sinon Sinon-chrome NYC Webpack CLI Spinner yargs Source hosted on Github Published on NPM","title":"Tech Stack"},{"location":"11-stack/#documentation","text":"MkDocs MkDocs material theme Built with Travis CI Served by Github Pages","title":"Documentation"},{"location":"12-helpful/","text":"Helpful References Some generally helpful links that may be useful when working with extension projects. Chrome Extension Development Resources Getting started with extension development Extension Development Intro Guide manifest.json Reference manifest.json reference Internationalization Supporting multiple languages Language locales list Webstore Resources Webstore Image Guide Chrome Web Store API","title":"Helpful References"},{"location":"12-helpful/#helpful-references","text":"Some generally helpful links that may be useful when working with extension projects.","title":"Helpful References"},{"location":"12-helpful/#chrome-extension-development-resources","text":"","title":"Chrome Extension Development Resources"},{"location":"12-helpful/#getting-started-with-extension-development","text":"Extension Development Intro Guide","title":"Getting started with extension development"},{"location":"12-helpful/#manifestjson-reference","text":"manifest.json reference","title":"manifest.json Reference"},{"location":"12-helpful/#internationalization","text":"Supporting multiple languages Language locales list","title":"Internationalization"},{"location":"12-helpful/#webstore-resources","text":"Webstore Image Guide Chrome Web Store API","title":"Webstore Resources"},{"location":"13-cli-development/","text":"Developing Extension CLI This CLI is built with numerous tools (see Tech Stack) and written in Javascript. The source code is available on Github . Project Organization Path Description \u2514 .github Github markdown files \u2514 cli all commands are defined here \u2514 config Static resources used by the commands in cli \u2514 guide Docs \u2514 /* Application root; various project config files Debugging the CLI Locally Fork the repo Clone the forked repo and launch your favorite web IDE Install packages npm install Link the local package npm link extension-cli You can now run any commands against the local source; you will need an extension project for this to make any sense though. You can create a new starter project by running npx extension-cli . When debugging the build command, you may need to go into ./config/build.json and change value of projectRootDir as it assumes it is running from node_modules of the extension project. This may not be true if you are using a locally linked package. When you are done, unlink the package: run npm unlink --no-save extension-cli on your project's directory to remove the local symlink. Run npm unlink on the module's directory to remove the global symlink. Debugging & Extending Documentation Fork the repo Clone the forked repo and launch your favorite markdown editor + terminal. The docs use Python package called mkdocs . You need to have that installed. Create a virtual environment: python3 -m venv env Activate the environment: source env/bin/activate (Win: env\\Scripts\\activate.bat ) Install requirements pip install -r requirements.txt Run the docs locally: mkdocs serve All written docs are in the guide directory. The configs are in mkdocs.yml in the root. These are the files you want to edit to make changes to the documentation.","title":"CLI Development"},{"location":"13-cli-development/#developing-extension-cli","text":"This CLI is built with numerous tools (see Tech Stack) and written in Javascript. The source code is available on Github .","title":"Developing Extension CLI"},{"location":"13-cli-development/#project-organization","text":"Path Description \u2514 .github Github markdown files \u2514 cli all commands are defined here \u2514 config Static resources used by the commands in cli \u2514 guide Docs \u2514 /* Application root; various project config files","title":"Project Organization"},{"location":"13-cli-development/#debugging-the-cli-locally","text":"Fork the repo Clone the forked repo and launch your favorite web IDE Install packages npm install Link the local package npm link extension-cli You can now run any commands against the local source; you will need an extension project for this to make any sense though. You can create a new starter project by running npx extension-cli . When debugging the build command, you may need to go into ./config/build.json and change value of projectRootDir as it assumes it is running from node_modules of the extension project. This may not be true if you are using a locally linked package. When you are done, unlink the package: run npm unlink --no-save extension-cli on your project's directory to remove the local symlink. Run npm unlink on the module's directory to remove the global symlink.","title":"Debugging the CLI Locally"},{"location":"13-cli-development/#debugging-extending-documentation","text":"Fork the repo Clone the forked repo and launch your favorite markdown editor + terminal. The docs use Python package called mkdocs . You need to have that installed. Create a virtual environment: python3 -m venv env Activate the environment: source env/bin/activate (Win: env\\Scripts\\activate.bat ) Install requirements pip install -r requirements.txt Run the docs locally: mkdocs serve All written docs are in the guide directory. The configs are in mkdocs.yml in the root. These are the files you want to edit to make changes to the documentation.","title":"Debugging &amp; Extending Documentation"}]}